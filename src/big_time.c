/*

	Hex Watch.

	Based on bigtime from cloudpebble.
	Font used: "Imagine" as pictures.
	'B' character modified to be different than the '8'.


 */

#include "pebble_os.h"
#include "pebble_app.h"
#include "pebble_fonts.h"

#include "resource_ids.auto.h"

#define MY_UUID {0xA3, 0xB7, 0x43, 0x26, 0x3E, 0x3C, 0x42, 0xE9, 0xB9, 0x12, 0x80, 0x42, 0xCF, 0x49, 0x7A, 0x4B}
PBL_APP_INFO(MY_UUID, "Hex Watch", "IzK", 1, 0, DEFAULT_MENU_ICON, APP_INFO_WATCH_FACE);

Window window;

//
// There's only enough memory to load about 6 of 10 required images
// so we have to swap them in & out...
//
// We have one "slot" per digit location on screen.
//
// Because layers can only have one parent we load a digit for each
// slot--even if the digit image is already in another slot.
//
// Slot on-screen layout:
//     0 1
//     2 3
//    4 5 6
//
#define TOTAL_IMAGE_SLOTS 7

#define NUMBER_OF_IMAGES 16

// These images are 70 x 70 pixels (i.e. a quarter of the display),
// black and white with the digit character centered in the image.
// (As generated by the `fonttools/font2png.py` script.)
const int IMAGE_RESOURCE_IDS[NUMBER_OF_IMAGES] = {
	RESOURCE_ID_IMAGE_NUM_0, RESOURCE_ID_IMAGE_NUM_1, RESOURCE_ID_IMAGE_NUM_2,
	RESOURCE_ID_IMAGE_NUM_3, RESOURCE_ID_IMAGE_NUM_4, RESOURCE_ID_IMAGE_NUM_5,
	RESOURCE_ID_IMAGE_NUM_6, RESOURCE_ID_IMAGE_NUM_7, RESOURCE_ID_IMAGE_NUM_8,
	RESOURCE_ID_IMAGE_NUM_9, RESOURCE_ID_IMAGE_NUM_A, RESOURCE_ID_IMAGE_NUM_B,
	RESOURCE_ID_IMAGE_NUM_C, RESOURCE_ID_IMAGE_NUM_D, RESOURCE_ID_IMAGE_NUM_E,
	RESOURCE_ID_IMAGE_NUM_F
};
const int IMAGE_SMALL_IDS[NUMBER_OF_IMAGES] = {
	RESOURCE_ID_IMAGE_SMALL_0, RESOURCE_ID_IMAGE_SMALL_1, RESOURCE_ID_IMAGE_SMALL_2,
	RESOURCE_ID_IMAGE_SMALL_3, RESOURCE_ID_IMAGE_SMALL_4, RESOURCE_ID_IMAGE_SMALL_5,
	RESOURCE_ID_IMAGE_SMALL_6, RESOURCE_ID_IMAGE_SMALL_7, RESOURCE_ID_IMAGE_SMALL_8,
	RESOURCE_ID_IMAGE_SMALL_9, RESOURCE_ID_IMAGE_SMALL_A, RESOURCE_ID_IMAGE_SMALL_B,
	RESOURCE_ID_IMAGE_SMALL_C, RESOURCE_ID_IMAGE_SMALL_D, RESOURCE_ID_IMAGE_SMALL_E,
	RESOURCE_ID_IMAGE_SMALL_F
};

const int x[TOTAL_IMAGE_SLOTS] = {0, 73, 0, 73, 0, 48, 96};
const int y[TOTAL_IMAGE_SLOTS] = {1, 1, 72, 72, 143, 143, 143};

BmpContainer image_containers[TOTAL_IMAGE_SLOTS];

#define EMPTY_SLOT -1

// The state is either "empty" or the digit of the image currently in
// the slot--which was going to be used to assist with de-duplication
// but we're not doing that due to the one parent-per-layer
// restriction mentioned above.
int image_slot_state[TOTAL_IMAGE_SLOTS] = {EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT};


void load_digit_image_into_slot(int slot_number, int digit_value)
{
	/*

		Loads the digit image from the application's resources and
		displays it on-screen in the correct location.

		Each slot is a quarter of the screen.

	*/

	image_slot_state[slot_number] = digit_value;
	if (slot_number < 4)
	{
		bmp_init_container(IMAGE_RESOURCE_IDS[digit_value], &image_containers[slot_number]);
	}
	else
	{
		bmp_init_container(IMAGE_SMALL_IDS[digit_value], &image_containers[slot_number]);
	}
	image_containers[slot_number].layer.layer.frame.origin.x = x[slot_number];
	image_containers[slot_number].layer.layer.frame.origin.y = y[slot_number];
	layer_add_child(&window.layer, &image_containers[slot_number].layer.layer);

}


void unload_digit_image_from_slot(int slot_number)
{
	/*

		Removes the digit from the display and unloads the image resource
		to free up RAM.

		Can handle being called on an already empty slot.

	*/

	if (image_slot_state[slot_number] != EMPTY_SLOT)
	{
		layer_remove_from_parent(&image_containers[slot_number].layer.layer);
		bmp_deinit_container(&image_containers[slot_number]);
		image_slot_state[slot_number] = EMPTY_SLOT;
	}
}


//void display_value(unsigned short value, unsigned short row_number, bool show_first_leading_zero)
void display_value(unsigned short value, unsigned short initial_slot, bool show_first_leading_zero)
{
	/*
		Displays a numeric value between 0 and FF on screen.

		Includes optional blanking of first leading zero,
		i.e. displays ' 0' rather than '00'.

	*/

	// We need to create an exception with month (only one character),
	// which depending on the date format (DayMonth or MonthDay) is diferent.

	// DayMonth
	int loop = (initial_slot==6)?initial_slot:initial_slot+1;
	
	//MonthDay
	//int loop = (initial_slot==4)?initial_slot:initial_slot+1;

	
	// (We process the slots in reverse order because that makes
	// extracting the digits from the value easier.)

	for (int slot = loop; slot >= initial_slot; slot--)
	{
		unload_digit_image_from_slot(slot);
		if (!((value == 0) && (slot == initial_slot) && !show_first_leading_zero))
		{
			load_digit_image_into_slot(slot, value % 16);
		}
		value = value / 16;
	}
}


unsigned short get_display_hour(unsigned short hour)
{
	if (clock_is_24h_style())
	{
		return hour;
	}

	unsigned short display_hour = hour % 12;

	// Converts "0" to "12"
	return display_hour ? display_hour : 12;

}


void display_time(PblTm *tick_time) {

	display_value(get_display_hour(tick_time->tm_hour), 0, false);
	display_value(tick_time->tm_min, 2, true);

	// We need to create call the function slightly different
	// depending on the preferred date format (DayMonth or MonthDay).
	
	//DayMonth (2 lines)
	display_value(tick_time->tm_mday, 4, true);
	display_value(tick_time->tm_mon+1, 6, false);

	//MonthDay (2 lines)
	//display_value(tick_time->tm_mday, 5, true);
	//display_value(tick_time->tm_mon+1, 4, false);
}


void handle_minute_tick(AppContextRef ctx, PebbleTickEvent *t)
{
	(void)t;
	(void)ctx;

	display_time(t->tick_time);
}


void handle_init(AppContextRef ctx)
{
	(void)ctx;

	window_init(&window, "Hex Watch");
	window_stack_push(&window, true);
	window_set_background_color(&window, GColorBlack);

	resource_init_current_app(&APP_RESOURCES);

	// Avoids a blank screen on watch start.
	PblTm tick_time;

	get_time(&tick_time);
	display_time(&tick_time);
}


void handle_deinit(AppContextRef ctx)
{
	(void)ctx;

	for (int i = 0; i < TOTAL_IMAGE_SLOTS; i++)
	{
		unload_digit_image_from_slot(i);
	}
}


void pbl_main(void *params)
{
	PebbleAppHandlers handlers = {
		.init_handler = &handle_init,
		.deinit_handler = &handle_deinit,

		.tick_info = {
			.tick_handler = &handle_minute_tick,
			.tick_units = MINUTE_UNIT
		}

	};
	app_event_loop(params, &handlers);
}
